/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).NativeWebKit={})}(this,(function(e){"use strict";class t{get eventTypes(){return[]}#e(e){return 0==this.eventTypes.length||this.eventTypes.includes(e)}#t(e){if(!this.#e(e))throw Error(`invalid event type "${e}"`)}#i;addEventListener(e,t,i){if(this.#t(e),this.#i||(this.#i={}),i?.once){const i=t;t=function t(s){i.apply(this,arguments),this.removeEventListener(e,t)}}const s=this.#i;s[e]||(s[e]=[]),s[e].includes(t)||s[e].push(t)}hasEventListener(e,t){return this.#t(e),this.#i?.[e]?.includes(t)}removeEventListener(e,t){if(this.#t(e),this.hasEventListener(e,t)){const i=this.#i[e].indexOf(t);return this.#i[e].splice(i,1),!0}return!1}dispatchEvent(e){if(this.#t(e.type),this.#i?.[e.type]){e.target=this;const t=this.#i[e.type].slice(0);for(let i=0,s=t.length;i<s;i++)t[i].call(this,e)}}get _prefix(){return""}_formatMessage(e){const t={...e};return t.type=`${this._prefix}-${e.type}`,t}}class i{#s=function(){};set prefix(e){const t=[console];e&&(Array.isArray(e)?t.push(...e):t.push(e)),this.#n=console.log.bind(...t),this.#a=console.warn.bind(...t),this.#o=console.error.bind(...t)}isLoggingEnabled=!0;get log(){return this.#s}#n=console.log.bind(console);isWarningEnabled=!0;get warn(){return this.#s}#a=console.warn.bind(console);isErrorEnabled=!0;get error(){return this.#s}#o=console.error.bind(console);set isEnabled(e){this.isLoggingEnabled=e,this.isWarningEnabled=e,this.isErrorEnabled=e}constructor(e){e&&(this.prefix=e)}}const s=new i,{userAgent:n}=navigator,a=/NativeWebKit/i.test(n);var o=Boolean(window.isNativeWebKitSafariExtensionInstalled);const r=async()=>!!o||(s.log("checking if Safari Extension is installed..."),new Promise((e=>{const t=()=>{s.log("Safari Extension is installed"),o=!0,e(!0)};window.addEventListener("nativewebkit-extension-is-installed",t,{once:!0}),window.dispatchEvent(new Event("is-nativewebkit-extension-installed")),window.setTimeout((()=>{o||(s.log("Safari Extension is not installed"),window.removeEventListener(t),e(!1))}),1)})));var l=a||o;const c=async()=>!!l||(l=await r()),d=new i,h=new Set;const p={};function v(e){Array.isArray(e)||(e=[e]),d.log("nativewebkit-receive messages",e),e.forEach((e=>{const[t,i]=e.type.split("-");d.log(`received "${t}" message of type "${i}"`,e),e.type=i,p[t]&&0!=p[t].length?p[t].forEach((t=>{d.log("triggering callback",t,"for message",e),t(e)})):d.warn("no callbacks listening for prefix",t)}))}async function g(e){if(await c()){if(d.log("sending message to app...",e),a){const t=await webkit.messageHandlers.nativewebkit_reply.postMessage(e);return d.log("app response",t),t&&v(t),!0}return new Promise((t=>{const i=function(){for(var e=0;h.has(e);)e++;return h.add(e),e}();window.dispatchEvent(new CustomEvent("nativewebkit-send",{detail:{message:e,id:i}})),window.addEventListener(`nativewebkit-receive-${i}`,(e=>{const s=e.detail;d.log(`did receive message for nativewebkit-receive-${i}?`,s),s||d.error(`didn't receive message for nativewebkit-receive-${i}`),t(s),h.delete(i)}),{once:!0})}))}d.warn("NativeWebKit.js is not enabled - run in the NativeWebKit app or enable the NativeWebKit Safari Web Extension")}window.__NATIVEWEBKIT_LISTENER_FLAG__||(window.__NATIVEWEBKIT_LISTENER_FLAG__=!0,d.log('adding "nativewebkit-receive" window listener'),window.addEventListener("nativewebkit-receive",(e=>{v(e.detail)})));const u=new i;function b(e,t){return 0===t?e:b(t,e%t)}function w(e){if(u.log("finding greatestCommonFactor of numbers",e),0==(e=e.filter((e=>e>0))).length)return null;const t=e.reduce(((e,t)=>b(e,t)));return u.log("greatestCommonFactor",t),0==t?null:t}const m=new i("AppMessagePoll");class f{#r=!1;async#l(){if(!await c())return!1;if(a)return this.#r;return await r()}static#c=[];static#d(e){return this.#c.includes(e)?(m.log("poll already included"),this.#c.indexOf(e)):this.#c.push(e)}static#h(e){return this.#c.includes(e)?(e.stop(),this.#c.splice(e,e.#p),this.#v(),!0):(m.log("poll wasn't included"),!1)}get#p(){return f.#c.indexOf(this)}#g;#u;#b=0;get interval(){return this.#u}set interval(e){e<=0?m.error(`invalid interval ${e}ms`):e!=this.#u?(this.#u=e,this.#w&&f.#v()):m.warn("assigning same interval")}constructor(e,t,i=!1){this.#g=e,this.#u=t,this.#r=i,f.#d(this)}static#m=null;static get#f(){return null!=this.#m}static#A=null;static get#y(){return this.#c.filter((e=>e.#E))}static get#M(){return this.#y.map((e=>e.#u))}static#k(){var e=w(this.#M);if(m.log(`new interval ${e}`),this.#A!=e)return m.log(`interval updated from ${this.#A} to ${e}`),this.#A=e,!0}static async#I(){const e=Date.now(),t=this.#y.filter((t=>e-t.#b>=t.#u)),i=t.map((e=>e.#g()));if(m.log("messages",i),i.length>0){const e=await g(i);m.log("didReceiveMessage?",e),e||m.error("app didn't receive message")}else m.log("no messages to send");t.forEach((t=>t.#b=e))}static#L(){this.#f?m.log("tried to start AppMessagePoll when it's already running"):null!=this.#A?(m.log(`starting interval at ${this.#A}`),this.#m=window.setInterval(this.#I.bind(this),this.#A)):m.log("null interval")}static#U(){this.#f?(window.clearInterval(this.#m),this.#m=null):m.log("tried to stop AppMessagePoll when it already isn't running")}static#v(e=!1){if(!this.#f&&!e)return;const t=this.#k();this.#f||t?(m.log("restarting..."),this.#U(),this.#L()):m.log("no need to restart")}#E=!1;get#w(){return f.#f&&this.#E}async start(){await this.#l()&&(this.#w?m.log("poll is already running"):(this.#E=!0,f.#v(!0)))}stop(){this.#w&&(this.#E=!1,f.#v())}destroy(){m.log("destroying poll",this),f.#h(this)}}const A=new i("HeadphoneMotionManager");class y extends t{static#T=["isAvailable","isActive","motionData","sensorLocation"];get eventTypes(){return y.#T}static#D=new y;static get shared(){return this.#D}get _prefix(){return"hm"}_formatMessage(e){return super._formatMessage(e)}addEventListener(e,t,i){return super.addEventListener(...arguments)}removeEventListener(e,t){return super.removeEventListener(...arguments)}hasEventListener(e,t){return super.hasEventListener(...arguments)}dispatchEvent(e){return super.dispatchEvent(...arguments)}constructor(){if(super(),this.shared)throw new Error("HeadphoneMotionManager is a singleton - use HeadphoneMotionManager.shared");var e,t;e=this.#_.bind(this),t=this._prefix,d.log(`adding callback with prefix "${t}"`,e),p[t]||(p[t]=[]),p[t].push(e),window.addEventListener("load",(()=>{this.#x&&this.checkIsAvailable()})),window.addEventListener("unload",(()=>{this.#$&&this.#O&&this.stopUpdates()}))}#x=!1;get checkAvailabilityOnLoad(){return this.#x}set checkAvailabilityOnLoad(e){if("boolean"!=typeof e)throw Error("invalid newValue for checkAvailabilityOnLoad",e);this.#x=e}#O=!1;get stopUpdatesOnUnload(){return this.#O}set stopUpdatesOnUnload(e){if("boolean"!=typeof e)throw Error("invalid newValue for stopUpdatesOnUnload",e);this.#O=e}#_(e){A.log(`received background message of type ${e.type}`,e);const{type:t}=e;switch(t){case"isAvailable":this.#P(e.isAvailable);break;case"isActive":this.#W(e.isActive);break;case"getData":this.#R(e.motionData);break;default:A.error(`uncaught message type ${t}`)}}#C=null;get isAvailable(){return Boolean(this.#C)}#P(e){this.#C!=e&&(this.#C=e,A.log(`updated isAvailable to ${e}`),this.dispatchEvent({type:"isAvailable",message:{isAvailable:this.isAvailable}}),this.#C&&this.checkIsActive())}async checkIsAvailable(){A.log("checking isAvailable..."),await g(this.#V)}get#V(){return this._formatMessage({type:"isAvailable"})}#$=null;get isActive(){return Boolean(this.#$)}#W(e){this.#$!=e&&(this.#$=e,A.log(`updated isActive to ${this.isActive}`),this.dispatchEvent({type:"isActive",message:{isActive:this.isActive}}),this.#N.stop(),this.#$?(A.log("starting motion data poll"),this.#S.start()):(A.log("stopping motion data poll"),this.#S.stop()))}async checkIsActive(){A.log("checking isActive"),await g(this.#H())}#H(){return this._formatMessage({type:"isActive"})}#N=new f(this.#H.bind(this),50,!0);async startUpdates(){this.isAvailable?this.isActive?A.warn("already active"):(A.log("starting motion updates"),this.#N.start(),await g(this.#F)):A.warn("not available")}get#F(){return this._formatMessage({type:"startUpdates"})}async stopUpdates(){this.isAvailable?this.isActive?(A.log("stopping motion updates"),this.#N.start(),await g(this.#K)):A.warn("already inactive"):A.warn("not available")}get#K(){return this._formatMessage({type:"stopUpdates"})}async toggleMotionUpdates(){this.isAvailable?this.isActive?await this.stopUpdates():await this.startUpdates():A.log("not available")}#B;get motionData(){return this.#B}get#j(){return this.motionData?.timestamp||0}#G=null;get sensorLocation(){return this.#G}#q(e){this.#G!=e&&(this.#G=e,A.log(`updated sensor location to ${e}`),this.dispatchEvent({type:"sensorLocation",message:{sensorLocation:this.sensorLocation}}))}#R(e){this.#B=e,A.log("received headphone motion data",this.motionData),this.dispatchEvent({type:"motionData",message:{motionData:this.motionData}}),this.#q(e.sensorLocation)}async checkMotionData(){A.log("checkMotionData"),await g(this.#z)}#z(){return this._formatMessage({type:"getData",timestamp:this.#j})}#S=new f(this.#z.bind(this),20)}var E=y.shared;e.HeadphoneMotionManager=E}));
