/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
class t{get eventTypes(){return[]}#t(t){return 0==this.eventTypes.length||this.eventTypes.includes(t)}#e(t){if(!this.#t(t))throw Error(`invalid event type "${t}"`)}#s;addEventListener(t,e,s){if(this.#e(t),this.#s||(this.#s={}),s?.once){const s=e;e=function e(i){s.apply(this,arguments),this.removeEventListener(t,e)}}const i=this.#s;i[t]||(i[t]=[]),i[t].includes(e)||i[t].push(e)}hasEventListener(t,e){return this.#e(t),this.#s?.[t]?.includes(e)}removeEventListener(t,e){if(this.#e(t),this.hasEventListener(t,e)){const s=this.#s[t].indexOf(e);return this.#s[t].splice(s,1),!0}return!1}dispatchEvent(t){if(this.#e(t.type),this.#s?.[t.type]){t.target=this;const e=this.#s[t.type].slice(0);for(let s=0,i=e.length;s<i;s++)e[s].call(this,t)}}get _prefix(){return""}_formatMessage(t){const e={...t};return e.type=`${this._prefix}-${t.type}`,e}}class e{#i=function(){};set prefix(t){const e=[console];t&&(Array.isArray(t)?e.push(...t):e.push(t)),this.#a=console.log.bind(...e),this.#n=console.warn.bind(...e),this.#o=console.error.bind(...e)}isLoggingEnabled=!0;get log(){return this.#i}#a=console.log.bind(console);isWarningEnabled=!0;get warn(){return this.#i}#n=console.warn.bind(console);isErrorEnabled=!0;get error(){return this.#i}#o=console.error.bind(console);set isEnabled(t){this.isLoggingEnabled=t,this.isWarningEnabled=t,this.isErrorEnabled=t}constructor(t){t&&(this.prefix=t)}}const s=new e,{userAgent:i}=navigator,a=/NativeWebKit/i.test(i);var n=Boolean(window.isNativeWebKitSafariExtensionInstalled);const o=async()=>!!n||(s.log("checking if Safari Extension is installed..."),new Promise((t=>{const e=()=>{s.log("Safari Extension is installed"),n=!0,t(!0)};window.addEventListener("nativewebkit-extension-is-installed",e,{once:!0}),window.dispatchEvent(new Event("is-nativewebkit-extension-installed")),window.setTimeout((()=>{n||(s.log("Safari Extension is not installed"),window.removeEventListener("nativewebkit-extension-is-installed",e),t(!1))}),1)})));var r=a||n;const l=async()=>!!r||(r=await o()),c=new e,d=new Set;const h={};function v(t){Array.isArray(t)||(t=[t]),c.log("nativewebkit-receive messages",t),t.forEach((t=>{const[e,s]=t.type.split("-");c.log(`received "${e}" message of type "${s}"`,t),t.type=s,h[e]&&0!=h[e].length?h[e].forEach((e=>{c.log("triggering callback",e,"for message",t),e(t)})):c.warn("no callbacks listening for prefix",e)}))}async function p(t){if(await l()){if(c.log("sending message to app...",t),a){const e=await webkit.messageHandlers.nativewebkit_reply.postMessage(t);return c.log("app response",e),e&&v(e),!0}return new Promise((e=>{const s=function(){for(var t=0;d.has(t);)t++;return d.add(t),t}();window.dispatchEvent(new CustomEvent("nativewebkit-send",{detail:{message:t,id:s}})),window.addEventListener(`nativewebkit-receive-${s}`,(t=>{const i=t.detail;c.log(`did receive message for nativewebkit-receive-${s}?`,i),i||c.error(`didn't receive message for nativewebkit-receive-${s}`),e(i),d.delete(s)}),{once:!0})}))}c.warn("NativeWebKit.js is not enabled - run in the NativeWebKit app or enable the NativeWebKit Safari Web Extension")}window.__NATIVEWEBKIT_LISTENER_FLAG__||(window.__NATIVEWEBKIT_LISTENER_FLAG__=!0,c.log('adding "nativewebkit-receive" window listener'),window.addEventListener("nativewebkit-receive",(t=>{v(t.detail)})));const g=new e;function u(t,e){return 0===e?t:u(e,t%e)}function b(t){if(g.log("finding greatestCommonFactor of numbers",t),0==(t=t.filter((t=>t>0))).length)return null;const e=t.reduce(((t,e)=>u(t,e)));return g.log("greatestCommonFactor",e),0==e?null:e}const w=new e("AppMessagePoll");class m{#r=!1;async#l(){if(!await l())return!1;if(a)return this.#r;return await o()}static#c=[];static#d(t){return this.#c.includes(t)?(w.log("poll already included"),this.#c.indexOf(t)):this.#c.push(t)}static#h(t){return this.#c.includes(t)?(t.stop(),this.#c.splice(t,t.#v),this.#p(),!0):(w.log("poll wasn't included"),!1)}get#v(){return m.#c.indexOf(this)}#g;#u;#b=0;get interval(){return this.#u}set interval(t){t<=0?w.error(`invalid interval ${t}ms`):t!=this.#u?(this.#u=t,this.#w&&m.#p()):w.warn("assigning same interval")}constructor(t,e,s=!1){this.#g=t,this.#u=e,this.#r=s,m.#d(this)}static#m=null;static get#A(){return null!=this.#m}static#y=null;static get#E(){return this.#c.filter((t=>t.#f))}static get#M(){return this.#E.map((t=>t.#u))}static#k(){var t=b(this.#M);if(w.log(`new interval ${t}`),this.#y!=t)return w.log(`interval updated from ${this.#y} to ${t}`),this.#y=t,!0}static async#I(){const t=Date.now(),e=this.#E.filter((e=>t-e.#b>=e.#u)),s=e.map((t=>t.#g()));if(w.log("messages",s),s.length>0){const t=await p(s);w.log("didReceiveMessage?",t),t||w.error("app didn't receive message")}else w.log("no messages to send");e.forEach((e=>e.#b=t))}static#L(){this.#A?w.log("tried to start AppMessagePoll when it's already running"):null!=this.#y?(w.log(`starting interval at ${this.#y}`),this.#m=window.setInterval(this.#I.bind(this),this.#y)):w.log("null interval")}static#U(){this.#A?(window.clearInterval(this.#m),this.#m=null):w.log("tried to stop AppMessagePoll when it already isn't running")}static#p(t=!1){if(!this.#A&&!t)return;const e=this.#k();this.#A||e?(w.log("restarting..."),this.#U(),this.#L()):w.log("no need to restart")}#f=!1;get#w(){return m.#A&&this.#f}async start(){await this.#l()&&(this.#w?w.log("poll is already running"):(this.#f=!0,m.#p(!0)))}stop(){this.#w&&(this.#f=!1,m.#p())}destroy(){w.log("destroying poll",this),m.#h(this)}}const A=new e("HeadphoneMotionManager");class y extends t{static#D=["isAvailable","isActive","motionData","sensorLocation"];get eventTypes(){return y.#D}static#T=new y;static get shared(){return this.#T}get _prefix(){return"hm"}_formatMessage(t){return super._formatMessage(t)}addEventListener(t,e,s){return super.addEventListener(...arguments)}removeEventListener(t,e){return super.removeEventListener(...arguments)}hasEventListener(t,e){return super.hasEventListener(...arguments)}dispatchEvent(t){return super.dispatchEvent(...arguments)}constructor(){if(super(),this.shared)throw new Error("HeadphoneMotionManager is a singleton - use HeadphoneMotionManager.shared");var t,e;t=this.#_.bind(this),e=this._prefix,c.log(`adding callback with prefix "${e}"`,t),h[e]||(h[e]=[]),h[e].push(t),window.addEventListener("load",(()=>{this.#x&&this.checkIsAvailable()})),window.addEventListener("unload",(()=>{this.#$&&this.#O&&this.stopUpdates()}))}#x=!1;get checkAvailabilityOnLoad(){return this.#x}set checkAvailabilityOnLoad(t){if("boolean"!=typeof t)throw Error("invalid newValue for checkAvailabilityOnLoad",t);this.#x=t}#O=!1;get stopUpdatesOnUnload(){return this.#O}set stopUpdatesOnUnload(t){if("boolean"!=typeof t)throw Error("invalid newValue for stopUpdatesOnUnload",t);this.#O=t}#_(t){A.log(`received background message of type ${t.type}`,t);const{type:e}=t;switch(e){case"isAvailable":this.#P(t.isAvailable);break;case"isActive":this.#R(t.isActive);break;case"getData":this.#W(t.motionData);break;default:A.error(`uncaught message type ${e}`)}}#C=null;get isAvailable(){return Boolean(this.#C)}#P(t){this.#C!=t&&(this.#C=t,A.log(`updated isAvailable to ${t}`),this.dispatchEvent({type:"isAvailable",message:{isAvailable:this.isAvailable}}),this.#C&&this.checkIsActive())}async checkIsAvailable(){A.log("checking isAvailable..."),await p(this.#V)}get#V(){return this._formatMessage({type:"isAvailable"})}#$=null;get isActive(){return Boolean(this.#$)}#R(t){this.#$!=t&&(this.#$=t,A.log(`updated isActive to ${this.isActive}`),this.dispatchEvent({type:"isActive",message:{isActive:this.isActive}}),this.#S.stop(),this.#$?(A.log("starting motion data poll"),this.#H.start()):(A.log("stopping motion data poll"),this.#H.stop()))}async checkIsActive(){A.log("checking isActive"),await p(this.#N())}#N(){return this._formatMessage({type:"isActive"})}#S=new m(this.#N.bind(this),50,!0);async startUpdates(){this.isAvailable?this.isActive?A.warn("already active"):(A.log("starting motion updates"),this.#S.start(),await p(this.#F)):A.warn("not available")}get#F(){return this._formatMessage({type:"startUpdates"})}async stopUpdates(){this.isAvailable?this.isActive?(A.log("stopping motion updates"),this.#S.start(),await p(this.#K)):A.warn("already inactive"):A.warn("not available")}get#K(){return this._formatMessage({type:"stopUpdates"})}async toggleMotionUpdates(){this.isAvailable?this.isActive?await this.stopUpdates():await this.startUpdates():A.log("not available")}#B;get motionData(){return this.#B}get#G(){return this.motionData?.timestamp||0}#j=null;get sensorLocation(){return this.#j}#q(t){this.#j!=t&&(this.#j=t,A.log(`updated sensor location to ${t}`),this.dispatchEvent({type:"sensorLocation",message:{sensorLocation:this.sensorLocation}}))}#W(t){this.#B=t,A.log("received headphone motion data",this.motionData),this.dispatchEvent({type:"motionData",message:{motionData:this.motionData}}),this.#q(t.sensorLocation)}async checkMotionData(){A.log("checkMotionData"),await p(this.#z)}#z(){return this._formatMessage({type:"getData",timestamp:this.#G})}#H=new m(this.#z.bind(this),20)}var E=y.shared;export{E as HeadphoneMotionManager};
