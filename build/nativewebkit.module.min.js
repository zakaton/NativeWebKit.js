/**
 * @copyright Zack Qattan 2024
 * @license MIT
 */
class e{#e=function(){};set prefix(e){const t=[console];e&&(Array.isArray(e)?t.push(...e):t.push(e)),this.#t=console.log.bind(...t),this.#s=console.warn.bind(...t),this.#i=console.error.bind(...t)}isLoggingEnabled=!1;get log(){return this.isLoggingEnabled?this.#t:this.#e}#t=console.log.bind(console);isWarningEnabled=!1;get warn(){return this.isWarningEnabled?this.#s:this.#e}#s=console.warn.bind(console);isErrorEnabled=!0;get error(){return this.isErrorEnabled?this.#i:this.#e}#i=console.error.bind(console);set isEnabled(e){this.isLoggingEnabled=e,this.isWarningEnabled=e,this.isErrorEnabled=e}constructor(e){e&&(this.prefix=e)}}const t=new e,{userAgent:s}=navigator,i=/Safari/i.test(s)&&!/Chrome/i.test(s),n=/NativeWebKit/i.test(s);var a=!1;const o=async()=>!!i&&(window.isNativeWebKitSafariExtensionInstalled?(t.log("window.isNativeWebKitSafariExtensionInstalled is true"),!0):new Promise((e=>{const s=()=>{t.log('received "nativewebkit-is-enabled" response from content.js'),a=!0,e(!0)};window.addEventListener("nativewebkit-is-enabled",s,{once:!0}),setTimeout((()=>{window.isNativeWebKitSafariExtensionInstalled&&(t.log("window.isNativeWebKitSafariExtensionInstalled is true after timeout"),e(!0)),t.log('"nativewebkit-is-enabled" timeout ran out'),a||(e(!1),window.removeEventListener("nativewebkit-is-enabled",s))}),0),t.log('sending "nativewebkit-is-enabled" request to content.js'),window.dispatchEvent(new Event("is-nativewebkit-enabled"))})));class r{get eventTypes(){return[]}#n(e){return 0==this.eventTypes.length||this.eventTypes.includes(e)}#a(e){if(!this.#n(e))throw Error(`invalid event type "${e}"`)}#o;addEventListener(e,t,s){if(this.#a(e),this.#o||(this.#o={}),s?.once){const s=t;t=function t(i){s.apply(this,arguments),this.removeEventListener(e,t)}}const i=this.#o;i[e]||(i[e]=[]),i[e].includes(t)||i[e].push(t)}hasEventListener(e,t){return this.#a(e),this.#o?.[e]?.includes(t)}removeEventListener(e,t){if(this.#a(e),this.hasEventListener(e,t)){const s=this.#o[e].indexOf(t);return this.#o[e].splice(s,1),!0}return!1}dispatchEvent(e){if(this.#a(e.type),this.#o?.[e.type]){e.target=this;const t=this.#o[e.type].slice(0);for(let s=0,i=t.length;s<i;s++)t[s].call(this,e)}}get _prefix(){return""}_formatMessage(e){const t={...e};return t.type=`${this._prefix}-${e.type}`,t}}const l=new e,d=new Set;const c={};function h(e,t){l.log(`adding callback with prefix "${t}"`,e),c[t]||(c[t]=[]),c[t].push(e)}function g(e){Array.isArray(e)||(e=[e]),l.log("nativewebkit-receive messages",e),e.forEach((e=>{const[t,s]=e.type.split("-");l.log(`received "${t}" message of type "${s}"`,e),e.type=s,c[t]&&0!=c[t].length?c[t].forEach((t=>{l.log("triggering callback",t,"for message",e),t(e)})):l.warn("no callbacks listening for prefix",t)}))}async function v(e){if(await(async()=>!!n||(a||(t.log("checking if safari extension is installed..."),a=await o(),t.log(`isSafariExtensionInstalled? ${a}`)),a))()){if(l.log("sending message to app...",e),n){const t=await webkit.messageHandlers.nativewebkit_reply.postMessage(e);return l.log("app response",t),t&&g(t),!0}return new Promise((t=>{const s=function(){for(var e=0;d.has(e);)e++;return d.add(e),e}();window.dispatchEvent(new CustomEvent("nativewebkit-send",{detail:{message:e,id:s}})),window.addEventListener(`nativewebkit-receive-${s}`,(e=>{const i=e.detail;l.log(`did receive message for nativewebkit-receive-${s}?`,i),i||l.error(`didn't receive message for nativewebkit-receive-${s}`),t(i),d.delete(s)}),{once:!0})}))}l.warn("NativeWebKit.js is not enabled - run in the NativeWebKit app or enable the NativeWebKit Safari Web Extension")}window.__NATIVEWEBKIT_LISTENER_FLAG__||(window.__NATIVEWEBKIT_LISTENER_FLAG__=!0,l.log('adding "nativewebkit-receive" window listener'),window.addEventListener("nativewebkit-receive",(e=>{g(e.detail)})));const p=new e;function u(e,t){return 0===t?e:u(t,e%t)}function b(e){if(p.log("finding greatestCommonFactor of numbers",e),0==(e=e.filter((e=>e>0))).length)return null;const t=e.reduce(((e,t)=>u(e,t)));return p.log("greatestCommonFactor",t),0==t?null:t}const w=new e("AppMessagePoll");class m{static async#r(){return o()}static#l=[];static#d(e){return this.#l.includes(e)?(w.log("poll already included"),this.#l.indexOf(e)):this.#l.push(e)}static#c(e){return this.#l.includes(e)?(e.stop(),this.#l.splice(e,e.#h),this.#g(),!0):(w.log("poll wasn't included"),!1)}get#h(){return m.#l.indexOf(this)}#v;#p;#u=0;get interval(){return this.#p}set interval(e){e<=0?w.error(`invalid interval ${e}ms`):e!=this.#p?(this.#p=e,this.#b&&m.#g()):w.warn("assigning same interval")}constructor(e,t){this.#v=e,this.#p=t,m.#d(this)}static#w=null;static get#m(){return null!=this.#w}static#E=null;static get#A(){return this.#l.filter((e=>e.#y))}static get#f(){return this.#A.map((e=>e.#p))}static#M(){var e=b(this.#f);if(w.log(`new interval ${e}`),this.#E!=e)return w.log(`interval updated from ${this.#E} to ${e}`),this.#E=e,!0}static async#k(){const e=Date.now(),t=this.#A.filter((t=>e-t.#u>=t.#p)),s=t.map((e=>e.#v()));if(w.log("messages",s),s.length>0){const e=await v(s);w.log("didReceiveMessage?",e),e||w.error("app didn't receive message")}else w.log("no messages to send");t.forEach((t=>t.#u=e))}static async#L(){this.#m?w.log("tried to start AppMessagePoll when it's already running"):null!=this.#E?(w.log(`starting interval at ${this.#E}`),this.#w=window.setInterval(this.#k.bind(this),this.#E)):w.log("null interval")}static#I(){this.#m?(window.clearInterval(this.#w),this.#w=null):w.log("tried to stop AppMessagePoll when it already isn't running")}static#g(e=!1){if(!this.#m&&!e)return;const t=this.#M();this.#m||t?(w.log("restarting..."),this.#I(),this.#L()):w.log("no need to restart")}#y=!1;get#b(){return m.#m&&this.#y}async start(){await m.#r()?this.#b?w.log("poll is already running"):(this.#y=!0,m.#g(!0)):w.warn("polling is not enabled")}stop(){this.#b&&(this.#y=!1,m.#g())}destroy(){w.log("destroying poll",this),m.#c(this)}}window.AppMessagePoll=m;const E=new e("AudioSessionManager");class A extends r{static#U=[];get eventTypes(){return A.#U}static#_=new A;static get shared(){return this.#_}get _prefix(){return"as"}_formatMessage(e){return super._formatMessage(e)}addEventListener(e,t,s){return super.addEventListener(...arguments)}removeEventListener(e,t){return super.removeEventListener(...arguments)}hasEventListener(e,t){return super.hasEventListener(...arguments)}dispatchEvent(e){return super.dispatchEvent(...arguments)}constructor(){if(super(),this.shared)throw new Error("AudioSessionManager is a singleton - use AudioSessionManager.shared");h(this.#T.bind(this),this._prefix),window.addEventListener("load",(()=>{})),window.addEventListener("unload",(()=>{}))}#T(e){E.log(`received background message of type ${e.type}`,e);const{type:t}=e;E.error(`uncaught message type ${t}`)}}var y=A.shared;const f=new e("HeadphoneMotionManager");class M extends r{static#U=["isAvailable","isActive","motionData","sensorLocation"];get eventTypes(){return M.#U}static#_=new M;static get shared(){return this.#_}get _prefix(){return"hm"}_formatMessage(e){return super._formatMessage(e)}addEventListener(e,t,s){return super.addEventListener(...arguments)}removeEventListener(e,t){return super.removeEventListener(...arguments)}hasEventListener(e,t){return super.hasEventListener(...arguments)}dispatchEvent(e){return super.dispatchEvent(...arguments)}constructor(){if(super(),this.shared)throw new Error("HeadphoneMotionManager is a singleton - use HeadphoneMotionManager.shared");h(this.#T.bind(this),this._prefix),window.addEventListener("load",(()=>{this.#D&&this.checkIsAvailable()})),window.addEventListener("unload",(()=>{this.#x&&this.#$&&this.stopUpdates()}))}#D=!1;get checkAvailabilityOnLoad(){return this.#D}set checkAvailabilityOnLoad(e){if("boolean"!=typeof e)throw Error("invalid newValue for checkAvailabilityOnLoad",e);this.#D=e}#$=!1;get stopUpdatesOnUnload(){return this.#$}set stopUpdatesOnUnload(e){if("boolean"!=typeof e)throw Error("invalid newValue for stopUpdatesOnUnload",e);this.#$=e}#T(e){f.log(`received background message of type ${e.type}`,e);const{type:t}=e;switch(t){case"isAvailable":this.#P(e.isAvailable);break;case"isActive":this.#O(e.isActive);break;case"getData":this.#W(e.motionData);break;default:f.error(`uncaught message type ${t}`)}}#S=null;get isAvailable(){return Boolean(this.#S)}#P(e){this.#S!=e&&(this.#S=e,f.log(`updated isAvailable to ${e}`),this.dispatchEvent({type:"isAvailable",message:{isAvailable:this.isAvailable}}),this.#S&&this.checkIsActive())}async checkIsAvailable(){f.log("checking isAvailable..."),await v(this.#R)}get#R(){return this._formatMessage({type:"isAvailable"})}#x=null;get isActive(){return Boolean(this.#x)}#O(e){this.#x!=e&&(this.#x=e,f.log(`updated isActive to ${this.isActive}`),this.dispatchEvent({type:"isActive",message:{isActive:this.isActive}}),this.#C.stop(),this.#x?(f.log("starting motion data poll"),this.#N.start()):(f.log("stopping motion data poll"),this.#N.stop()))}async checkIsActive(){f.log("checking isActive"),await v(this.#V())}#V(){return this._formatMessage({type:"isActive"})}#C=new m(this.#V.bind(this),50);async startUpdates(){this.isAvailable?this.isActive?f.warn("already active"):(f.log("starting motion updates"),this.#C.start(),await v(this.#K)):f.warn("not available")}get#K(){return this._formatMessage({type:"startUpdates"})}async stopUpdates(){this.isAvailable?this.isActive?(f.log("stopping motion updates"),this.#C.start(),await v(this.#H)):f.warn("already inactive"):f.warn("not available")}get#H(){return this._formatMessage({type:"stopUpdates"})}async toggleMotionUpdates(){this.isAvailable?this.isActive?await this.stopUpdates():await this.startUpdates():f.log("not available")}#F;get motionData(){return this.#F}get#B(){return this.motionData?.timestamp||0}#j=null;get sensorLocation(){return this.#j}#G(e){this.#j!=e&&(this.#j=e,f.log(`updated sensor location to ${e}`),this.dispatchEvent({type:"sensorLocation",message:{sensorLocation:this.sensorLocation}}))}#W(e){this.#F=e,f.log("received headphone motion data",this.motionData),this.dispatchEvent({type:"motionData",message:{motionData:this.motionData}}),this.#G(e.sensorLocation)}async checkMotionData(){f.log("checkMotionData"),await v(this.#q)}#q(){return this._formatMessage({type:"getData",timestamp:this.#B})}#N=new m(this.#q.bind(this),20)}var k=M.shared;export{y as AudioSessionManager,k as HeadphoneMotionManager};
